{"ast":null,"code":"import { QuizRound } from \"src/app/model/QuizRoundModel\"; // import { questionsRoundDTO } from \"./IQuestionsDTO\";\n\nvar FetchMethod;\n\n(function (FetchMethod) {\n  FetchMethod[\"GET\"] = \"GET\";\n  FetchMethod[\"POST\"] = \"POST\";\n  FetchMethod[\"PUT\"] = \"PUT\";\n  FetchMethod[\"DELETE\"] = \"DELETE\";\n})(FetchMethod || (FetchMethod = {}));\n\nexport const convertToDTOProject = quizRound => {\n  return {\n    question: quizRound.question,\n    choices: quizRound.choices,\n    rightAnswer: quizRound.rightAnswer,\n    key: quizRound.key\n  };\n};\nexport const convertToProject = projectDTO => {\n  return new QuizRound({\n    question: String(projectDTO.question),\n    choices: String(projectDTO.choices),\n    rightAnswer: String(projectDTO.rightAnswer),\n    key: String(projectDTO.key)\n  });\n};\n\nconst request = async (url, method, body) => {\n  const stringifiedBody = JSON.stringify(body);\n  const rawResponse = await fetch(url, {\n    method,\n    headers: {\n      accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringifiedBody\n  }); // обработка ответа\n\n  if (rawResponse.ok) {\n    return method !== FetchMethod.DELETE ? rawResponse.json() : undefined;\n  }\n\n  throw new Error(String(rawResponse.status));\n};\n\nexport const fetchRequest = {\n  /**\n  * Создание get запроса\n  */\n  get: async url => {\n    return request(url, FetchMethod.GET);\n  }\n};\n/**\n * Class which use when the client have internet\n */\n\nexport class QuizService {\n  constructor(baseUrl) {\n    this.baseUrl = void 0;\n    this.baseUrl = baseUrl;\n  }\n  /**\n  * Method which return data\n  */\n\n\n  async getQuestions() {\n    const url = this.baseUrl;\n    const {\n      content: questionsRoundDTO\n    } = await fetchRequest.get(url);\n    const questions = questionsRoundDTO.map(convertToProject);\n    return questions;\n  }\n\n}","map":{"version":3,"names":["QuizRound","FetchMethod","convertToDTOProject","quizRound","question","choices","rightAnswer","key","convertToProject","projectDTO","String","request","url","method","body","stringifiedBody","JSON","stringify","rawResponse","fetch","headers","accept","ok","DELETE","json","undefined","Error","status","fetchRequest","get","GET","QuizService","constructor","baseUrl","getQuestions","content","questionsRoundDTO","questions","map"],"sources":["/home/ekaterina/quiz/client/src/app/service/QuizService.ts"],"sourcesContent":["import {QuizRound} from \"src/app/model/QuizRoundModel\";\n// import { questionsRoundDTO } from \"./IQuestionsDTO\";\n\nenum FetchMethod {\n  GET = \"GET\",\n  POST = \"POST\",\n  PUT = \"PUT\",\n  DELETE = \"DELETE\",\n}\n\nexport type DTO<T> = Record<keyof T, any>\n\nexport const convertToDTOProject = (quizRound: QuizRound): DTO<QuizRound> => {\n  return {\n    question: quizRound.question,\n    choices: quizRound.choices,\n    rightAnswer: quizRound.rightAnswer,\n    key: quizRound.key,\n  };\n};\n\nexport const convertToProject = (projectDTO: DTO<QuizRound>): QuizRound => {\n  return new QuizRound({\n    question: String(projectDTO.question),\n    choices: String(projectDTO.choices),\n    rightAnswer: String(projectDTO.rightAnswer),\n    key: String(projectDTO.key),\n  });\n};\n\nconst request = async (url: string, method: FetchMethod, body?: unknown | undefined) => {\n  const stringifiedBody = JSON.stringify(body);\n  const rawResponse = await fetch(url, {\n    method,\n    headers: {\n      accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringifiedBody,\n  });\n\n  // обработка ответа\n  if (rawResponse.ok) {\n    return method !== FetchMethod.DELETE\n      ? rawResponse.json()\n      : undefined;\n  }\n\n  throw new Error(String(rawResponse.status));\n};\n\nexport const fetchRequest = {\n\n  /**\n\t * Создание get запроса\n\t */\n  get: async <T>(url: string): Promise<T> => {return request(url, FetchMethod.GET);},\n\n};\n\n/**\n * Class which use when the client have internet\n */\nexport class QuizService {\n\n  private baseUrl: string;\n\n  constructor(baseUrl: string) {\n    this.baseUrl = baseUrl;\n  }\n\n  /**\n\t * Method which return data\n\t */\n  public async getQuestions(): Promise<QuizRound[]> {\n    const url = this.baseUrl;\n    const {content: questionsRoundDTO} = await fetchRequest.get(url);\n\n    const questions = questionsRoundDTO.map(convertToProject);\n\n    return questions;\n  }\n\n}\n"],"mappings":"AAAA,SAAQA,SAAR,QAAwB,8BAAxB,C,CACA;;IAEKC,W;;WAAAA,W;EAAAA,W;EAAAA,W;EAAAA,W;EAAAA,W;GAAAA,W,KAAAA,W;;AASL,OAAO,MAAMC,mBAAmB,GAAIC,SAAD,IAA0C;EAC3E,OAAO;IACLC,QAAQ,EAAED,SAAS,CAACC,QADf;IAELC,OAAO,EAAEF,SAAS,CAACE,OAFd;IAGLC,WAAW,EAAEH,SAAS,CAACG,WAHlB;IAILC,GAAG,EAAEJ,SAAS,CAACI;EAJV,CAAP;AAMD,CAPM;AASP,OAAO,MAAMC,gBAAgB,GAAIC,UAAD,IAA2C;EACzE,OAAO,IAAIT,SAAJ,CAAc;IACnBI,QAAQ,EAAEM,MAAM,CAACD,UAAU,CAACL,QAAZ,CADG;IAEnBC,OAAO,EAAEK,MAAM,CAACD,UAAU,CAACJ,OAAZ,CAFI;IAGnBC,WAAW,EAAEI,MAAM,CAACD,UAAU,CAACH,WAAZ,CAHA;IAInBC,GAAG,EAAEG,MAAM,CAACD,UAAU,CAACF,GAAZ;EAJQ,CAAd,CAAP;AAMD,CAPM;;AASP,MAAMI,OAAO,GAAG,OAAOC,GAAP,EAAoBC,MAApB,EAAyCC,IAAzC,KAAwE;EACtF,MAAMC,eAAe,GAAGC,IAAI,CAACC,SAAL,CAAeH,IAAf,CAAxB;EACA,MAAMI,WAAW,GAAG,MAAMC,KAAK,CAACP,GAAD,EAAM;IACnCC,MADmC;IAEnCO,OAAO,EAAE;MACPC,MAAM,EAAE,kBADD;MAEP,gBAAgB;IAFT,CAF0B;IAMnCP,IAAI,EAAEC;EAN6B,CAAN,CAA/B,CAFsF,CAWtF;;EACA,IAAIG,WAAW,CAACI,EAAhB,EAAoB;IAClB,OAAOT,MAAM,KAAKZ,WAAW,CAACsB,MAAvB,GACHL,WAAW,CAACM,IAAZ,EADG,GAEHC,SAFJ;EAGD;;EAED,MAAM,IAAIC,KAAJ,CAAUhB,MAAM,CAACQ,WAAW,CAACS,MAAb,CAAhB,CAAN;AACD,CAnBD;;AAqBA,OAAO,MAAMC,YAAY,GAAG;EAE1B;AACF;AACA;EACEC,GAAG,EAAE,MAAUjB,GAAV,IAAsC;IAAC,OAAOD,OAAO,CAACC,GAAD,EAAMX,WAAW,CAAC6B,GAAlB,CAAd;EAAsC;AALxD,CAArB;AASP;AACA;AACA;;AACA,OAAO,MAAMC,WAAN,CAAkB;EAIvBC,WAAW,CAACC,OAAD,EAAkB;IAAA,KAFrBA,OAEqB;IAC3B,KAAKA,OAAL,GAAeA,OAAf;EACD;EAED;AACF;AACA;;;EAC2B,MAAZC,YAAY,GAAyB;IAChD,MAAMtB,GAAG,GAAG,KAAKqB,OAAjB;IACA,MAAM;MAACE,OAAO,EAAEC;IAAV,IAA+B,MAAMR,YAAY,CAACC,GAAb,CAAiBjB,GAAjB,CAA3C;IAEA,MAAMyB,SAAS,GAAGD,iBAAiB,CAACE,GAAlB,CAAsB9B,gBAAtB,CAAlB;IAEA,OAAO6B,SAAP;EACD;;AAlBsB"},"metadata":{},"sourceType":"module"}